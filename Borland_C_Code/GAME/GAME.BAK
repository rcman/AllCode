// Defender style game like Datastorm
// Date Start: April 23, 1995
// Revision: May 7, 1995
// Single Bottom Screen Scroll
// Task List    Init Screen
//              Load Objects
//              Init Enemies
//              Calculate Coords
//              Move Enemies
//              Scroll Screen
//**********************************************************
//    PUT (x, SIN(ya * (3.14159267# / 180)) * 60 + 100), Box%, XOR
//        LOCATE 1, 1: PRINT SIN(ya); ya; yac
//        yao = ya
//        xo = x
//        PUT (x, SIN(ya * (3.14159267# / 180)) * 60 + 100), Box%, XOR
//        ya = ya + yac
//        IF ya > 360 THEN ya = 0: ' ya = 360
//        'IF ya < 0 THEN yac = 1: ya = 0
//        x = x + .3
//        FOR t = 1 TO 10: NEXT t
//        PUT (xo, SIN(yao * (3.14159267# / 180)) * 60 + 100), Box%, XOR
//        GOTO mainloop
//

#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <alloc.h>
#include <memory.h>
#include <string.h>
#include <time.h>
#include <math.h>
// #include <complex.h>

//#include <conio.h>
//#include <graphics.h>
#pragma inline
void Init_Mode(void);
void Close_Mode(void);
void CutImage(int saveareax, int savesreay, int spritenum);
void PutImage(int spx,int spy, int spritenum );
void RestoreBack(int spx,int spy, int spritenum );
void getch(void);
void initarray(void);
void copypage(char *source, char *destin);
int kbhit(void);
int getkey(void);

//Global

char far *screen = MK_FP(0xa000,0);
char far *destin;
					// 16 x 16 array
static char ship1[32][16] = {

    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
    { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },


    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x12, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x13, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x14, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x15, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x16, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x17, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x18, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x19, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },
    { 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01,0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01 },

  };

void *buffer;
void *image;

unsigned int imsize;
int top = 290;
int bottom = 35;
int rbottom = 300;
int lbottom = 145;
int spx=100;            // Pixels
int spy=100;
int spritenum=0;
int lp;
int x,y,xy1,xy,fl,tm;
int z=0;
int offset = 0;
int numspr=10;
int sprloc=16;

struct ship {
		int shipox;
		int shipoy;
		int shipx;
		int shipy;
		int shipspeed;
		char far *saveback;

	 } shipanim[40];

void initarray(void)
{


	int c,sn,tempx,tempy;
	randomize();
	destin = (char far  *) farmalloc(64000l);
	_fmemset(destin, 0, 64000l);

	if (destin == NULL)
		{
		     printf("Not enough memory to allocate screen buffer\n");
		     Close_Mode();
		     exit(1);  /* terminate program if out of memory */

		}

	for (c=0 ; c<numspr; c++)
	{
		tempx=random(319);
		tempy=random(169);

		shipanim[c].shipx=tempx;
		shipanim[c].shipy=tempy;

//		printf("%d",shipanim[c].shipx);
  //		getkey();

		shipanim[c].shipspeed=random(6)+1;
	    // if ((shipanim[c].saveback = (char far  *) farmalloc(260)) == NULL)
	     //	{
	     //	     printf("Not enough memory to allocate buffer\n");
	      //	     exit(1);  /* terminate program if out of memory */
	      //	}

		PutImage(shipanim[c].shipx, shipanim[c].shipy, c);
		}

}


void main(void)
{
	int i,direction=1,xx,swav;

	Init_Mode();

	initarray();

    //	printf("Ok Start\n");

//	copypage(screen, destin);


	//for (lp=0;lp<645;lp++)
	do
	{
	     for (xx=0; xx<numspr; xx++)
	      {

	//     spritenum=xx;
  //		    z=xx;
//		    z=spritenum;

		      spx = shipanim[xx].shipx;
		      spy = shipanim[xx].shipy;;
		      shipanim[xx].shipox = spx;
		      shipanim[xx].shipoy = spy;

		      spx += shipanim[xx].shipspeed;

		      if (spx >= 319)
		      {

			spx=1;
			}

		      shipanim[xx].shipx = spx;

		      PutImage(shipanim[xx].shipox,spy,spritenum);
		      //CutImage(spx,spy,spritenum);
		      PutImage(spx,spy,spritenum);
		}
	      copypage(destin,screen);
	      for (tm=0 ;tm<13350 ; tm++)
	      {
		       printf("");
	      }
	     // getkey();
	} while (!kbhit());


	/* free memory */
	for (i=0 ; i<numspr ; i++)
	{
		farfree(shipanim[i].saveback);
	}
	farfree(destin);

	Close_Mode();
}






void Init_Mode(void)
{
	asm {
		mov ax,0x13
		int 0x10
	    }
}

void Close_Mode()
{

	asm {
		mov ax,0x03
		int 0x10
		}

}

void CutImage(int spx,int spy, int spritenum)
{
	int i=0;
	offset=spy*320+spx;

	for (x=0;x<16;x++)
	{
		for (y=0;y<16;y++)
		{
			*(shipanim[spritenum].saveback+i)=*(screen+y+offset);
			i++;
		}
		offset = offset + 320;      //bytes to next line
	}


}







void PutImage(int spx,int spy,int spritenum)
{
	offset=spy*320+spx;

	for (x=sprloc;x<sprloc+16;x++)
	{
		for (y=sprloc;y<sprloc+16;y++)
		{
		  *(destin+y+offset)^=ship1[y][x];
		}
		offset = offset + 320;      //bytes to next line
	}
	if (sprloc==16)
		sprloc=0;

	else
	{
		sprloc=16;
	}
	       //	printf("%d",sprloc);

}

void RestoreBack(int spx,int spy, int spritenum)
{
	int i=0;
	offset=spy*320+spx;

	for (x=0;x<16;x++)
	{
		for (y=0;y<16;y++)
		{
			 *(screen+y+offset)=*(shipanim[spritenum].saveback+i);
			i++;
		}
		offset = offset + 320;      //bytes to next line
	}

}

void copypage(char *source, char *destin)
{
//	printf("Start ASM");
	asm {
	    .386
	    push ds
	    cld
	    lds si, [source]
	    les di, [destin]
	    mov cx, 16000
	    rep movsd
	    pop ds
	    }
}




int getkey()
{

	getchar();

}
